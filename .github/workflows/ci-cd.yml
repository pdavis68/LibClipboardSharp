name: CI/CD Pipeline

# Trigger events for the workflow
on:
  # CI: Run on pull requests targeting main branch
  pull_request:
    branches: [ main ]
  
  # CD: Run on pushes to main branch and version tags
  push:
    branches: [ main ]
    tags: [ 'v*.*.*' ]

  # Allow manual workflow dispatch for testing
  workflow_dispatch:

env:
  DOTNET_VERSION: '8.0.x'
  PROJECT_PATH: './LibClipboardSharp.csproj'
  SOLUTION_PATH: './LibClipboardSharp.sln'

jobs:
  # Continuous Integration Job - runs on PRs and pushes
  ci:
    name: Continuous Integration
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest, macos-latest]
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0 # Fetch full history for GitVersion

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Cache NuGet packages
      uses: actions/cache@v3
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Restore dependencies
      run: dotnet restore ${{ env.SOLUTION_PATH }}

    - name: Build project
      run: dotnet build ${{ env.SOLUTION_PATH }} --no-restore --configuration Release

    - name: Run tests
      run: dotnet test ${{ env.SOLUTION_PATH }} --no-build --configuration Release --verbosity normal

  # Continuous Deployment Job - runs on main branch pushes and tags
  cd:
    name: Continuous Deployment
    runs-on: ubuntu-latest
    needs: ci
    # Only run on main branch pushes or version tags
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Extract version from tag
      id: version
      run: |
        if [[ $GITHUB_REF == refs/tags/v* ]]; then
          VERSION=${GITHUB_REF#refs/tags/v}
          PACKAGE_VERSION=$VERSION
          # For assembly version, extract only the numeric part (major.minor.patch.revision)
          ASSEMBLY_VERSION=$(echo $VERSION | sed -E 's/^([0-9]+\.[0-9]+\.[0-9]+).*$/\1.0/')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "assembly_version=$ASSEMBLY_VERSION" >> $GITHUB_OUTPUT
          echo "is_release=true" >> $GITHUB_OUTPUT
          
          # Check if this is a pre-release (contains alpha, beta, rc, or has a dash)
          if [[ $VERSION == *"alpha"* ]] || [[ $VERSION == *"beta"* ]] || [[ $VERSION == *"rc"* ]] || [[ $VERSION == *"-"* ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
          fi
        else
          # Use timestamp for main branch builds
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          PACKAGE_VERSION="1.0.0-ci.$TIMESTAMP"
          # Assembly version must be numeric only (major.minor.build.revision)
          ASSEMBLY_VERSION="1.0.0.$(($(date +%s) % 65535))"
          echo "version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "assembly_version=$ASSEMBLY_VERSION" >> $GITHUB_OUTPUT
          echo "is_release=false" >> $GITHUB_OUTPUT
          echo "is_prerelease=false" >> $GITHUB_OUTPUT
        fi
        echo "Detected package version: $PACKAGE_VERSION"
        echo "Detected assembly version: $ASSEMBLY_VERSION"

    - name: Restore dependencies
      run: dotnet restore ${{ env.SOLUTION_PATH }}

    - name: Build for multiple platforms
      run: |
        # Build for each target platform
        platforms=("win-x64" "win-x86" "win-arm64" "linux-x64" "linux-arm64" "osx-x64" "osx-arm64")
        
        for platform in "${platforms[@]}"; do
          echo "Building for $platform..."
          dotnet publish ${{ env.PROJECT_PATH }} \
            --configuration Release \
            --runtime $platform \
            --self-contained false \
            --output "./publish/$platform" \
            -p:Version=${{ steps.version.outputs.package_version }} \
            -p:AssemblyVersion=${{ steps.version.outputs.assembly_version }} \
            -p:FileVersion=${{ steps.version.outputs.assembly_version }}
        done

    - name: Pack NuGet package
      run: |
        mkdir -p ./nupkg
        dotnet pack ${{ env.PROJECT_PATH }} \
          --configuration Release \
          --output ./nupkg \
          -p:PackageVersion=${{ steps.version.outputs.package_version }} \
          -p:Version=${{ steps.version.outputs.package_version }} \
          -p:AssemblyVersion=${{ steps.version.outputs.assembly_version }} \
          -p:FileVersion=${{ steps.version.outputs.assembly_version }}
        
        # List the contents to verify the package was created
        echo "Contents of ./nupkg directory:"
        ls -la ./nupkg/

    - name: Upload NuGet package artifact
      uses: actions/upload-artifact@v4
      with:
        name: nuget-package
        path: ./nupkg/*.nupkg

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts
        path: ./publish/

    # Publish to NuGet.org (runs for both main branch and tags)
    - name: Publish to NuGet
      run: |
        # Verify the package exists before attempting to push
        if [ ! -d "./nupkg" ] || [ -z "$(ls -A ./nupkg)" ]; then
          echo "Error: No NuGet packages found in ./nupkg directory"
          echo "Directory contents:"
          ls -la ./
          exit 1
        fi
        
        echo "Found packages to push:"
        ls -la ./nupkg/
        
        dotnet nuget push ./nupkg/*.nupkg \
          --api-key ${{ secrets.NUGET_API_KEY }} \
          --source https://api.nuget.org/v3/index.json \
          --skip-duplicate
      env:
        NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}

  # GitHub Release Job - only runs on version tags
  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: cd
    if: startsWith(github.ref, 'refs/tags/v')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Extract version from tag
      id: version
      run: |
        VERSION=${GITHUB_REF#refs/tags/v}
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        
        # Check if this is a pre-release
        if [[ $VERSION == *"alpha"* ]] || [[ $VERSION == *"beta"* ]] || [[ $VERSION == *"rc"* ]] || [[ $VERSION == *"-"* ]]; then
          echo "is_prerelease=true" >> $GITHUB_OUTPUT
        else
          echo "is_prerelease=false" >> $GITHUB_OUTPUT
        fi

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: build-artifacts
        path: ./publish/

    - name: Download NuGet package
      uses: actions/download-artifact@v4
      with:
        name: nuget-package
        path: ./nupkg/

    - name: Create release archives
      run: |
        mkdir -p ./release-assets
        
        # Create zip files for each platform
        platforms=("win-x64" "win-x86" "win-arm64" "linux-x64" "linux-arm64" "osx-x64" "osx-arm64")
        
        for platform in "${platforms[@]}"; do
          if [ -d "./publish/$platform" ]; then
            echo "Creating archive for $platform..."
            cd "./publish/$platform"
            zip -r "../../release-assets/LibClipboardSharp-v${{ steps.version.outputs.version }}-$platform.zip" .
            cd ../..
          fi
        done
        
        # Copy NuGet package to release assets
        cp ./nupkg/*.nupkg ./release-assets/

    - name: Extract changelog for this version
      id: changelog
      run: |
        if [ -f "CHANGELOG.md" ]; then
          # Extract the changelog section for this version
          awk '/^## \['"${{ steps.version.outputs.version }}"'\]/{flag=1; next} /^## \[/{flag=0} flag' CHANGELOG.md > current_changelog.txt
          
          # If the changelog is empty, create a default message
          if [ ! -s current_changelog.txt ]; then
            echo "Release ${{ steps.version.outputs.version }} of LibClipboardSharp" > current_changelog.txt
            echo "" >> current_changelog.txt
            echo "See [CHANGELOG.md](CHANGELOG.md) for full details." >> current_changelog.txt
          fi
        else
          echo "Release ${{ steps.version.outputs.version }} of LibClipboardSharp" > current_changelog.txt
        fi
        
        # Set the changelog content as output (handling multiline)
        {
          echo 'changelog<<EOF'
          cat current_changelog.txt
          echo EOF
        } >> $GITHUB_OUTPUT

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ steps.version.outputs.version }}
        name: LibClipboardSharp v${{ steps.version.outputs.version }}
        body: ${{ steps.changelog.outputs.changelog }}
        prerelease: ${{ steps.version.outputs.is_prerelease }}
        files: ./release-assets/*
        draft: false
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Cleanup job - removes old artifacts
  cleanup:
    name: Cleanup Artifacts
    runs-on: ubuntu-latest
    needs: [cd, release]
    if: always()
    
    steps:
    - name: Delete artifacts
      uses: geekyeggo/delete-artifact@v2
      with:
        name: |
          build-artifacts
          nuget-package
        failOnError: false
