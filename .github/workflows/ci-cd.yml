name: CI / CD / Releases

# Comprehensive pipeline for LibClipboardSharp
# - CI: matrix build & test on PRs (Windows, Ubuntu, macOS) and on pushes to main
# - CD: pack and push NuGet package on pushes to main (derives version from tag if present)
# - Release: when a tag matching v*.*.* is pushed, build platform-specific publish artifacts,
#            create a GitHub Release, and attach zipped artifacts. Uses CHANGELOG.md for body if present.

on:
  pull_request:
    branches: [ main ]

  push:
    branches: [ main ]
    tags:
      - 'v*.*.*'

jobs:
  # Continuous Integration: runs on PRs and on push to main to ensure gate for CD
  ci:
    name: CI - build
    runs-on: ${{ matrix.os }}
    if: github.event_name == 'pull_request' || (github.event_name == 'push' && github.ref == 'refs/heads/main')
    strategy:
      fail-fast: false
      matrix:
        os: [windows-latest, ubuntu-latest, macos-latest]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x'

      - name: .NET info (debug)
        run: |
          echo "=== dotnet --info ==="
          dotnet --info || true
          echo "=== dotnet --list-sdks ==="
          dotnet --list-sdks || true
          echo "=== dotnet --list-runtimes ==="
          dotnet --list-runtimes || true

      - name: Restore
        run: |
          dotnet restore

      - name: Build (Release)
        run: |
          dotnet build --configuration Release --no-restore

      # Pack and upload package only on one matrix runner to avoid duplicate artifacts
      - name: Pack NuGet package (CI runner)
        if: matrix.os == 'ubuntu-latest'
        run: |
          set -euo pipefail
          mkdir -p artifacts
          echo "Packing project for artifact upload (diagnostic)"
          # Capture verbose output so we can see where the package is written (or why none is written)
          dotnet pack ./LibClipboardSharp.csproj --configuration Release -o artifacts /p:PackageOutputPath=artifacts --verbosity diagnostic 2>&1 | tee pack.log || true
          echo "--- pack log (last 200 lines) ---"
          tail -n 200 pack.log || true
          echo "--- listing artifacts/ ---"
          ls -la artifacts || true
          echo "--- find any .nupkg in the repo ---"
          find . -type f -name '*.nupkg' -not -path './obj/*' -not -path '*/obj/*' -print -ls || true

  # Continuous Deployment: pack and push NuGet when code is pushed to main
  cd:
    name: CD - pack & push NuGet
    needs: ci
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x'

      - name: Determine project file
        id: proj
        run: |
          if [ -f "./src/LibClipboardSharp/LibClipboardSharp.csproj" ]; then
            echo "PROJECT=./src/LibClipboardSharp/LibClipboardSharp.csproj" >> $GITHUB_ENV
          elif [ -f "./LibClipboardSharp.csproj" ]; then
            echo "PROJECT=./LibClipboardSharp.csproj" >> $GITHUB_ENV
          else
            echo "Could not find LibClipboardSharp.csproj" >&2
            exit 1
          fi

      - name: Get version from tag (if any)
        id: get_version
        run: |
          VERSION=""
          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            VERSION_NAME=${GITHUB_REF#refs/tags/}
            # strip leading 'v' from tag (v1.2.3 -> 1.2.3)
            VERSION=${VERSION_NAME#v}
            echo "Found tag: $VERSION_NAME -> using package version: $VERSION"
          else
            echo "No tag on this push; pack will use project version metadata if present."
          fi
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Pack NuGet package
        run: |
            set -euo pipefail
            # Always cd to the project directory before packing
            if [ -n "${PROJECT:-}" ]; then
              projdir=$(dirname "$PROJECT")
              projfile=$(basename "$PROJECT")
              cd "$projdir"
              mkdir -p "$GITHUB_WORKSPACE/artifacts"
              echo "Packing $projfile from $(pwd)"
              dotnet restore "$projfile"
              if [ -n "${VERSION}" ]; then
                dotnet pack "$projfile" --configuration Release -o "$GITHUB_WORKSPACE/artifacts" /p:PackageVersion=${VERSION} /p:PackageOutputPath="$GITHUB_WORKSPACE/artifacts"
              else
                dotnet pack "$projfile" --configuration Release -o "$GITHUB_WORKSPACE/artifacts" /p:PackageOutputPath="$GITHUB_WORKSPACE/artifacts"
              fi
            else
              echo "No PROJECT env var set, scanning for .csproj files to pack."
              mapfile -t CS_PROJS < <(find . -maxdepth 3 -type f -name '*.csproj' -not -path './obj/*' | sort)
              if [ ${#CS_PROJS[@]} -eq 0 ]; then
                echo "No .csproj files found to pack." >&2
                exit 1
              fi
              for p in "${CS_PROJS[@]}"; do
                projdir=$(dirname "$p")
                projfile=$(basename "$p")
                cd "$projdir"
                mkdir -p "$GITHUB_WORKSPACE/artifacts"
                echo "Packing $projfile from $(pwd)"
                dotnet restore "$projfile"
                if [ -n "${VERSION}" ]; then
                  dotnet pack "$projfile" --configuration Release -o "$GITHUB_WORKSPACE/artifacts" /p:PackageVersion=${VERSION} /p:PackageOutputPath="$GITHUB_WORKSPACE/artifacts"
                else
                  dotnet pack "$projfile" --configuration Release -o "$GITHUB_WORKSPACE/artifacts" /p:PackageOutputPath="$GITHUB_WORKSPACE/artifacts"
                fi
                cd "$GITHUB_WORKSPACE"
              done
            fi
            echo "--- After pack: list all .nupkg files in repo ---"
            find . -type f -name '*.nupkg' -print -ls || true
            echo "--- Artifacts directory contents ---"
            ls -la "$GITHUB_WORKSPACE/artifacts" || true

      - name: List created packages
        run: |
          echo "Checking artifacts for .nupkg files"
          if compgen -G "artifacts/*.nupkg" > /dev/null; then
            echo "Found packages in artifacts/:"
            ls -la artifacts
          else
            echo "No .nupkg found in artifacts/ after pack." >&2
            echo "Workspace top-level files:" && ls -la || true
            echo "Failing the job so missing package production is visible." >&2
            exit 1
          fi

      

      - name: Push package to nuget.org
        env:
          NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}
        run: |
          set -euo pipefail
          echo "Looking for .nupkg files to push..."

          PKG_LIST=""

          # Prefer artifacts folder created by dotnet pack
          if compgen -G "artifacts/*.nupkg" > /dev/null; then
            PKG_LIST=$(printf "%s\n" artifacts/*.nupkg)
          fi

          # If none found, look for common pack/build output locations
          if [ -z "$PKG_LIST" ]; then
            # Try bin/**/Release
            if compgen -G "bin/**/Release/*.nupkg" > /dev/null 2>/dev/null; then
              PKG_LIST=$(printf "%s\n" bin/**/Release/*.nupkg)
            fi
          fi

          # Final fallback: search the repo for any .nupkg (exclude obj folders)
          if [ -z "$PKG_LIST" ]; then
            PKG_LIST=$(find . -type f -name '*.nupkg' -not -path './obj/*' -not -path '*/obj/*' -print)
          fi

          if [ -z "${PKG_LIST}" ]; then
            echo "No packages found to push." >&2
            echo "Checked: artifacts/*.nupkg, bin/**/Release/*.nupkg, and repository-wide find." >&2
            ls -la || true
            exit 1
          fi

          echo "Packages to push:"
          echo "$PKG_LIST"

          while IFS= read -r pkg; do
            [ -z "$pkg" ] && continue
            echo "Pushing $pkg"
            dotnet nuget push "$pkg" -k "$NUGET_API_KEY" -s https://api.nuget.org/v3/index.json --skip-duplicate
          done <<< "$PKG_LIST"

  # Build platform-specific publish artifacts for a release tag. Produces zips uploaded as workflow artifacts.
  build_artifacts:
    name: Build publish artifacts
    if: startsWith(github.ref, 'refs/tags/v') && github.event_name == 'push'
    strategy:
      fail-fast: false
      matrix:
        include:
          - runner: windows-latest
            rid: win-x86
            publish_dir: ./src/LibClipboardSharp/bin/Release/net6.0/win-x86/publish
          - runner: windows-latest
            rid: win-x64
            publish_dir: ./src/LibClipboardSharp/bin/Release/net6.0/win-x64/publish
          - runner: windows-latest
            rid: win-arm64
            publish_dir: ./src/LibClipboardSharp/bin/Release/net6.0/win-arm64/publish
          - runner: ubuntu-latest
            rid: linux-x64
            publish_dir: ./src/LibClipboardSharp/bin/Release/net6.0/linux-x64/publish
          - runner: ubuntu-latest
            rid: linux-arm64
            publish_dir: ./src/LibClipboardSharp/bin/Release/net6.0/linux-arm64/publish
          - runner: macos-latest
            rid: osx-x64
            publish_dir: ./src/LibClipboardSharp/bin/Release/net6.0/osx-x64/publish
          - runner: macos-latest
            rid: osx-arm64
            publish_dir: ./src/LibClipboardSharp/bin/Release/net6.0/osx-arm64/publish

    runs-on: ${{ matrix.runner }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x'

      - name: Determine project file
        run: |
          if [ -f "./src/LibClipboardSharp/LibClipboardSharp.csproj" ]; then
            echo "PROJECT=./src/LibClipboardSharp/LibClipboardSharp.csproj" >> $GITHUB_ENV
          elif [ -f "./LibClipboardSharp.csproj" ]; then
            echo "PROJECT=./LibClipboardSharp.csproj" >> $GITHUB_ENV
          else
            echo "Could not find LibClipboardSharp.csproj" >&2
            exit 1
          fi

      - name: Publish for RID ${{ matrix.rid }}
        run: |
          set -euo pipefail
          echo "Publishing RID=${{ matrix.rid }} to output ${{ matrix.publish_dir }}"
          mkdir -p "$(dirname "${{ matrix.publish_dir }}")"
          dotnet publish "$PROJECT" -c Release -r ${{ matrix.rid }} --self-contained false -f net6.0 -o "${{ matrix.publish_dir }}"

      - name: Prepare zip artifact
        run: |
          mkdir -p ./artifacts
          ZIP_PATH=./artifacts/${{ matrix.rid }}.zip
          if [[ "${{ runner.os }}" == "Windows" || "${{ matrix.runner }}" == "windows-latest" ]]; then
            powershell -Command "if (Test-Path '${{ matrix.publish_dir }}') { Compress-Archive -Path '${{ matrix.publish_dir }}\\*' -DestinationPath '${ZIP_PATH}' -Force } else { Write-Error 'Publish dir not found' ; exit 1 }"
          else
            if [ -d "${{ matrix.publish_dir }}" ]; then
              (cd "${{ matrix.publish_dir }}" && zip -r "${ZIP_PATH}" .)
            else
              echo "Publish dir not found: ${{ matrix.publish_dir }}" && exit 1
            fi
          fi

      - name: Upload zip as workflow artifact
        uses: actions/upload-artifact@v4
        with:
          name: publish-${{ matrix.rid }}
          path: ./artifacts/${{ matrix.rid }}.zip

  # Create GitHub Release and attach artifacts when a release tag is pushed
  create_release:
    name: Create Release and attach artifacts
    runs-on: ubuntu-latest
    needs: build_artifacts
    if: startsWith(github.ref, 'refs/tags/v') && github.event_name == 'push'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download built artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./downloaded_artifacts
      - name: Prepare release notes (CHANGELOG.md or fallback)
        id: release_notes
        run: |
          if [ -f CHANGELOG.md ]; then
            RELEASE_BODY=$(cat CHANGELOG.md)
          else
            RELEASE_BODY="Release $GITHUB_REF_NAME"
          fi
          if [[ "${GITHUB_REF#refs/tags/}" == *"-"* ]]; then
            PRERELEASE=true
          else
            PRERELEASE=false
          fi
          # Use GITHUB_OUTPUT to expose outputs for other steps
          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "prerelease=$PRERELEASE" >> $GITHUB_OUTPUT

      - name: Create GitHub release
        id: create_release
        uses: actions/create-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          release_name: ${{ github.ref_name }}
          body: ${{ steps.release_notes.outputs.body }}
          draft: false
          prerelease: ${{ steps.release_notes.outputs.prerelease }}

      - name: Create combined artifacts zip
        run: |
          cd downloaded_artifacts
          zip -r ../all-artifacts.zip .
          cd ..

      - name: Upload combined artifacts to Release
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./all-artifacts.zip
          asset_name: all-artifacts.zip
          asset_content_type: application/zip
